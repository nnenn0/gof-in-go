# gof-in-go

(「xxx パターンを使用することによって何が嬉しいのかを教えてください。」というプロンプトを ChatGPT に投げて出力している)

- [Behavioral patterns](#behavioral-patterns)
  - [Iterator](#iterator)

## Behavioral patterns

### Iterator

#### 概要

Iterator パターンは、コレクション（配列やリストなど）の内部構造を隠蔽しながら、その要素を順番に走査するためのデザインパターンです。

#### メリット

##### データ構造のカプセル化

- `BookShelf` の内部構造（スライス `books`）を外部に公開せず、安全に要素を走査できる。
- 外部から `books` に直接アクセスせずに、`Iterator` を通じて要素を取得できるため、データ構造の変更に柔軟に対応可能。

##### 一貫したインターフェースの提供

- 異なるデータ構造（例: `LinkedListBookShelf`）でも、`Iterator` インターフェースを実装すれば同じ方法で走査可能。
- すべてのコレクションに `HasNext()` & `Next()` の操作を統一できる。

##### 開放・閉鎖原則（OCP: Open/Closed Principle）

- `BookShelf` のデータ構造を変更（例: スライス → マップ）しても、`Iterator` のインターフェースを変えなければ、利用側のコードに影響を与えない。

##### 複数のイテレーション戦略を適用可能

- `BookShelfIterator` とは別に、逆順に走査する `ReverseBookShelfIterator` などを作成できる。
- クライアントは `BookShelf` の内部を意識せず、目的に応じたイテレータを選択可能。

##### 並列処理との相性が良い

- `Iterator` の設計次第で、スレッドごとに異なるイテレータを作成し、並列でデータを処理できる。

#### まとめ

Iterator パターンを使用することで、**データ構造の詳細を隠蔽しつつ、統一的な方法で要素を走査できる** ようになります。異なるデータ構造でも共通のインターフェースを通じて扱えるため、柔軟な設計が可能になります。
