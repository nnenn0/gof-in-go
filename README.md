# gof-in-go

## ChatGPT 出力プロンプト

```Markdown
xxxパターンを使用することによって何が嬉しいのかを教えてください。
READMEに追記したいので、以下の形式を使用してMarkdown形式で書いてください。

### Adapter
#### メリット
##### {具体的なメリットの見出し}
#### まとめ
```

- [Behavioral patterns](#behavioral-patterns)
  - [Iterator](#iterator)
- [Structural patterns](#structural-patterns)
  - [Adapter](#adapter)

## Behavioral patterns

### Iterator

#### 概要

Iterator パターンは、コレクション（配列やリストなど）の内部構造を隠蔽しながら、その要素を順番に走査するためのデザインパターンです。

#### メリット

##### データ構造のカプセル化

- `BookShelf` の内部構造（スライス `books`）を外部に公開せず、安全に要素を走査できる。
- 外部から `books` に直接アクセスせずに、`Iterator` を通じて要素を取得できるため、データ構造の変更に柔軟に対応可能。

##### 一貫したインターフェースの提供

- 異なるデータ構造（例: `LinkedListBookShelf`）でも、`Iterator` インターフェースを実装すれば同じ方法で走査可能。
- すべてのコレクションに `HasNext()` & `Next()` の操作を統一できる。

##### 開放・閉鎖原則（OCP: Open/Closed Principle）

- `BookShelf` のデータ構造を変更（例: スライス → マップ）しても、`Iterator` のインターフェースを変えなければ、利用側のコードに影響を与えない。

##### 複数のイテレーション戦略を適用可能

- `BookShelfIterator` とは別に、逆順に走査する `ReverseBookShelfIterator` などを作成できる。
- クライアントは `BookShelf` の内部を意識せず、目的に応じたイテレータを選択可能。

##### 並列処理との相性が良い

- `Iterator` の設計次第で、スレッドごとに異なるイテレータを作成し、並列でデータを処理できる。

#### まとめ

Iterator パターンを使用することで、**データ構造の詳細を隠蔽しつつ、統一的な方法で要素を走査できる** ようになります。異なるデータ構造でも共通のインターフェースを通じて扱えるため、柔軟な設計が可能になります。

## Structural patterns

### Adapter

#### メリット

##### 既存コードの再利用

`Banner` は `encloseInParen` や `encloseInAster` を持っていますが、直接 `Wrap` インターフェースに適合しません。  
`WrapBanner` を Adapter として作ることで、`Banner` の既存ロジックを `Wrap` インターフェースを通じて再利用できます。

##### 異なるインターフェースの統一

`Wrap` インターフェースを持つ他の型があった場合でも、`WrapBanner` を使えば統一的に扱うことができます。

##### 変更の影響を抑える

`Banner` の実装を直接変更せずに、新しいインターフェース (`Wrap`) に適合させられるため、既存の `Banner` を利用している他の部分への影響を最小限にできます。

##### 依存関係の明確化

`Wrap` インターフェースを利用することで、具体的な `Banner` への依存を減らし、より柔軟な設計が可能になります（依存性の逆転の原則に近いメリット）。

#### まとめ

Adapter パターンを使用することで、既存のコードを変更せずに新しいインターフェースに適合させることができ、柔軟で拡張しやすい設計を実現できます。
